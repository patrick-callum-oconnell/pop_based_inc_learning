/*
* This file holds the driver code for PBIL.
*
* The return value is the best solution that the PBIL has found
* in the latest generation.
*
* Author: Patrick O'Connell
* Date: 3/18/21
*/

#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>
#include<string.h>
#include <time.h>
#include "helper_pbil.h"
#include"datatypes.h"
#include "dependencies.h"

void main(int argc, char**argv) {

  //how often we want print statements (may add command-line access to this variable later):
  int epoch = 100;

  //for measuring function time
  clock_t start_time;
  double time_elapsed;

  start_time = clock();

  //"instance" variables
  bool invalid_arg = false; //used in evaluating validity of arguments
  problem maxsat_problem;
  bool max_fitness_reached = false;
  int max_fitness;
  int vector_len; //number of bits in prob_vector / individual

  int i, j; //iterators

  //COMMAND LINE ARGUMENTS:
  int pop_size; //num vectors generated by prob_vector for a given generation
  double lr; //learning rate
  double negative_lr; //negative learning rate
  double mut_probability; //mutation probability for a given bit
  double mut_shift; //amount mutation alters a bit
  int max_iterations; //maximum number of iterations/generations
  char* file_name; //name of .cnf file
  int print_generations;

  if (argc < 9) {
    //takes 8 arguments, so if we have less than 9 (incl. function call)
    //we must have invalid arguments.
    printf("Insufficient arguments.\n");
    invalid_arg = true;
  }

  if (invalid_arg) {

    printf("\n");
    printf("PBIL takes the following arguments:\n"); 
    printf("(1) pop_size, int, number of vectors generated by prob_vector for a given population,\n");
    printf("(2) lr, double, the learning rate,\n");
    printf("(3) negative_lr, double, the negative learning rate,\n");
    printf("(4) mut_probability, mutation probability for a given bit,\n");
    printf("(5) mut_shift, the amount mutation alters a bit,\n");
    printf("(6) max_iterations, int, the maximum number of iterations allowed,\n");
    printf("(7) file_name, string, the name of the .cnf file\n");
    printf("(8) print_generations, int, 1 if yes, 0 if no\n");
    printf("\n");

    return;
  }

  char *ptr; //for use in strtod
  //load input parameters
  pop_size = atoi(argv[1]);
  lr = strtod(argv[2], &ptr);
  negative_lr = strtod(argv[3], &ptr);
  mut_probability = strtod(argv[4], &ptr);
  mut_shift = strtod(argv[5], &ptr);
  max_iterations = atoi(argv[6]);
  file_name = argv[7];
  print_generations = atoi(argv[8]);

  maxsat_problem = read_cnf(file_name); //loads cnf information into our problem struct
                                        //for fitness evaluation
  max_fitness = maxsat_problem.n_clauses; //max fitness is satisfying all clauses

  vector_len = maxsat_problem.n_variables; //sets length of our probability vector / individual
                                           //once we've found the number of variables with read_cnf()

  //init probability vector w/ probabilities starting at .5
  double* prob_vector = (double*) malloc(vector_len * sizeof(double));
  for (i = 0; i < vector_len; i++) {
    prob_vector[i] = 0.5;
  }

  //init vectors to hold best and worst individuals of population
  int* best_vector = (int*) malloc(vector_len * sizeof(int));
  int best_fitness;
  int* worst_vector = (int*) malloc(vector_len * sizeof(int));
  int* best_global_vector = (int*) malloc((vector_len + 1) * sizeof(int));
  //init them as 0s
  for (i = 0; i < vector_len; i++) {
    best_vector[i] = 0;
    worst_vector[i] = 0;
    best_global_vector[i] = 0;
  }

  //best global vector is a special individual which holds the best individual we've ever found
  //where index 0 isn't part of the vector, but actually specifies the generation at which
  //we've found the best_global_vector
  int best_global_fitness; //fitness value of best_global_vector
  best_global_fitness = get_fitness(best_vector, &maxsat_problem);

  //init current_population as empty population
  int** current_population = (int**) malloc(pop_size * sizeof(int*)); //individuals
  for (i = 0; i < pop_size; i++) {
    current_population[i] = (int*) malloc(vector_len * sizeof(int));
  }
  
  printf("\nBeginning iterative process...\n");

  //now iterate for as many generations as we need to reach max fitness with an individual of a population
  //or until max iterations
  int iteration = 0;
  while ((iteration < max_iterations) && !max_fitness_reached) {

    //every epoch, print results
    if (print_generations == 1) {
      if (iteration % epoch == 0) {
        printf("Generation: %d\n", iteration);
        printf("Best individual: <");
        for (i = 0; i < vector_len; i++) {
          printf("%d ", best_vector[i]);
        }
        printf(">\n");
        printf("Worst individual: <");
        for (i = 0; i < vector_len; i++) {
          printf("%d ", worst_vector[i]);
        }
        printf(">\n");

        printf("Probability Vector: <");
        for (i = 0; i < vector_len; i++) {
          printf("%.3f ", prob_vector[i]);
        }
        printf(">\n\n");
      }
    }

    //shifting probability vector occurs at beginning of while loop because we don't want the probability
    //vector to be changed if we reach the max fitness with a population
    if (i > 0) {
      //shift bits of prob_vector based on best/worst individuals
      prob_vector = update_prob_vector(prob_vector, vector_len, best_vector, worst_vector, lr, negative_lr);

      //mutation
      prob_vector = mutate(prob_vector, mut_probability, mut_shift);
    }

    //generates new pop, stores in old
    current_population = generate_population(current_population, prob_vector, pop_size, vector_len);

    //evaluates best and worst of current pop
    best_vector = findBest(current_population, pop_size, vector_len, &maxsat_problem);
    best_fitness = get_fitness(best_vector, &maxsat_problem);

    if (best_fitness == max_fitness) {
      printf("Reached max fitness w/ candidate solution!\n");
      max_fitness_reached = true; //found optimal before max iterations, so record that
    }

    //if current best is better than global best, replace global best and indicate generation
    if (best_fitness > best_global_fitness) {

      best_global_fitness = best_fitness;
      best_global_vector[0] = iteration;
      for (i = 1; i < (vector_len + 1); i++) {
        best_global_vector[i] = best_vector[i - 1];
      }
    }

    worst_vector = findWorst(current_population, pop_size, vector_len, max_fitness, &maxsat_problem);

    iteration++;
  } 

  time_elapsed = ((double) (clock() - start_time)) / CLOCKS_PER_SEC;

  //final print report
  printf("Algorithm completed successfully.\nTime elapsed: %.2f seconds\n\n", time_elapsed);
  printf("Results for problem %s (%d variables, %d clauses):\n", file_name, maxsat_problem.n_variables, maxsat_problem.n_clauses);
  printf("----------------------------------------------\n");
  printf("Total generations created: %d\n", iteration);
  //best vector & its fitness
  printf("Best candidate solution found: <");
  for (i = 1; i < (vector_len + 1); i++) {
    printf("%d ", best_global_vector[i]);
  }
  printf(">\n");
  printf("at generation %d\n", best_global_vector[0]);
  printf("Candidate fitness: satisfied %d of %d clauses ", best_global_fitness, max_fitness);

  double print_fitness = (((double) best_global_fitness) / ((double) max_fitness)) * 100;

  printf("(%.02f%% fit)\n", print_fitness);

  //add statistic about average fitness?

  printf("----------------------------------------------\n");

  //free memory
  free(prob_vector);
  free(best_vector);
  free(best_global_vector);
  //free(best_vector) //can't free this because we're returning it
  free(worst_vector);
  for (i = 0; i < pop_size; i++) {
    free(current_population[i]);
  }
  free(current_population);

  return;
 
}