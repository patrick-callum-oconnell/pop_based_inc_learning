/* This holds all of the helper functions for PBIL.
*
*   Author: Patrick O'Connell
*/
#include "helper_pbil.h"
#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>
#include"datatypes.h"
#include "dependencies.h"

/* Generate population function takes the array that holds the current population
*  and overwrites it with the new population, generated by the prob vector
*  @param current_population, int[][], a 2d array where each row is an individual
*  @param prob_vector, double[], probability vector for generating populations
*  @param pop_size, the number of individuals we want in our population
*  @param length, the length of any given individual (technically we dont 
*  need this because we could just find the length of the probability vector)
*/
int** generate_population(int** current_population, double* prob_vector, int pop_size, int length) {

  double pop_bit_check; //used for probability check for if current bit will be 1

  for (int i = 0; i < pop_size; i++) {
    for (int j = 0; j < length; j++) {

        pop_bit_check = (double) rand() / RAND_MAX;

        if (pop_bit_check <= prob_vector[j]) {
          current_population[i][j] = 1;
        }
        else {
          current_population[i][j] = 0;
        }
    }
  }

  return current_population;
}

/* Updates probability vector towards best individual in current population
* and away from the worst individual
*  @param prob_vector, double[], probability vector for generating populations
*  @param length, the length of any given individual
*  @param best_vector, int[], the best individual
*  @param worst_vector, int[], the worst individual
*  @param lr, double, the learning rate
*  @param negative_lr, double, the negative learning rate
*/
double* update_prob_vector(double* prob_vector, int length, int* best_vector, int* worst_vector, double lr, double negative_lr) {
  
  //towards best vector
  for (int i = 0; i < length; i++) {
    prob_vector[i] = prob_vector[i] * (1.0 - lr) + best_vector[i] * lr;
  }
        
  //away from worst vector (if not bit not equal to best_vector bit)
  for (int i = 0; i < length; i++) {
    if (best_vector[i] != worst_vector[i]) {
      prob_vector[i] = prob_vector[i] * (1.0 - negative_lr) + best_vector[i] * negative_lr;
    }
  }

  return prob_vector;

}

/* Looks through every individual in current population
*  returns the most fit.
*/
int* findBest(int** current_population, int pop_size, int length, problem* prob) {

  int best_individual = 0; //init best individual
  int max_fitness = 0;
  int current_fitness;

  //for each individual, check if it is the best
  //if it is, store index in best_individual
  for (int i = 0; i < pop_size; i++) {

      current_fitness = get_fitness(current_population[i], prob);
      //printf("fitness %d: %d\n", i, current_fitness);
      //for (int j = 0; j < length; j++) {
      //  printf("%d", current_population[i][j]);
      //}
      //printf("\n");
      if (current_fitness > max_fitness) {
        max_fitness = current_fitness;
        best_individual = i; //found better individual
      }
  }

  return current_population[best_individual];

}

//Looks through every individual in current population
//returns the least fit
int* findWorst(int** current_population, int pop_size, int length, int max_fitness, problem* prob) {

  int worst_individual = 0; //init worst individual
  int worst_fitness = max_fitness; //init at high because we are minimizing
  int current_fitness;

  //for each individual, check if it is the best
  //if it is, store index in best_individual
  for (int i = 0; i < pop_size; i++) {

      current_fitness = get_fitness(current_population[i], prob);
      //printf("fitness %d: %d", i, current_fitness);
      if (current_fitness < worst_fitness) {
        worst_fitness = current_fitness;
        worst_individual = i; //found better individual
      }
  }

  return current_population[worst_individual];

}g


/* Mutation function that takes in a vector of doubles
*  and mutates that vector based on the following parameters
*  @param prob_vector - double[], the probability vector that will be altered
*  @param mut_probability - double, probability that any bit will mutatea
*  @param mut_shift - double, the amount we want a bit to mutate if it does
*/
double* mutate(double* prob_vector, double mut_probability, double mut_shift) {
  
  int arr_len = sizeof(prob_vector);
  double mut_check; //current iteration probability to check mut_prob
  int mutate_direction; //tracks which direction to mutate vector

  for (int i = 0; i < arr_len; i++) {
    
    //get random number to do mutation prob check
    mut_check = (double) rand() / RAND_MAX;

    if (mut_check <= mut_probability) {
      mutate_direction = 1;
    }
    else {
      mutate_direction = 0;
    }
    prob_vector[i] = prob_vector[i] * (1.0 - mut_shift) + mutate_direction * (mut_shift);
  }
  
  return prob_vector;
}

